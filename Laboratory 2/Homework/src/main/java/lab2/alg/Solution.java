/**
 * @author RÄƒzvan-Morcov Pahoncea
 * @version
 */

package lab2.alg;
import lab2.model.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Class implementing a greedy approach to solving the problem given by/generated by the <code>Problem</code> class.
 */
public class Solution {
    private final List<Event> eventList;
    private final List<Room> roomList;

    private final List<Event> eventSolution;
    private final List<Room> roomSolution;

    public Solution(Problem p) {
        eventList = p.getEventList();
        roomList = p.getRoomList();
        eventSolution = new ArrayList<>();
        roomSolution = new ArrayList<>();
    }

    /**
     * Greedy approach to solving the problem, iterating through all the rooms (sorted ascending by capacity)
     * and trying to fit as many events into each one; if no more events can be fitted, then the next room
     * is checked.
     */
    public void greedySolve() {
        Utils.sortLists(this.eventList, this.roomList);

        for (Event event : eventList) {
            for (Room room : roomList) {
                if (event.getSize() <= room.getCapacity() && roomAvailable(event, room)) break;
            }
        }

        if (eventSolution.size() == eventList.size()) {
            Utils.sortLists(eventSolution, roomSolution);
            for (int index = 0; index < eventSolution.size(); index++) {
                System.out.print(eventSolution.get(index).getName() + " (" + eventSolution.get(index).getSize() + "): "
                        + eventSolution.get(index).getStartTime() + " - " + eventSolution.get(index).getEndTime() +
                        " -> " + roomSolution.get(index).getName() + " (" + roomSolution.get(index).getCapacity() +
                        ")\n");
            }
        } else
            System.out.println("No solution found!");
    }

    /**
     * Checks if a certain <code>room</code> is available during the <code>event.startTime</code> and
     * <code>event.endTime</code>; if the check passes, the event is associated with the room; otherwise,
     * another room is searched.
     */
    private boolean roomAvailable(Event event, Room room) {
        int index;
        for (index = 0; index < roomSolution.size(); index++) {
            Event e = eventList.get(index);
            if (roomSolution.get(index) == room)
                if (Utils.rangesOverlap(e.getStartTime(), e.getEndTime(), event.getStartTime(), event.getEndTime()))
                    return false;
        }

        if (index == roomSolution.size()) {
            eventSolution.add(event);
            roomSolution.add(room);
            return true;
        }
        return false;
    }
}
